-- DML (DATA Manipulation Language) : 데이터 조작어
-- 현재 유저에 속한 테이블 목록보기
SELECT * FROM USER_TABLES;

-- 참고) ROLLACK / COMMIT
-- *트랜잭션(Transaction) 관리
-- ROLLACK : INSERT/UPDATE/DELETE 실행을 취소하는 것
-- COMMIT : INSERT/UPDATE/DELETE 실행 영구 반영
-- 예) 트랜잭션 시작
--     insert ~
--     update ~
--     delete ~
--     commit [rollback] : 트랜잭션 종료 (1개의 트랜잭션)
-- 참고) AUTOCOMMIT : 자동 DB 영구 반영
-- ORACLE DB : AUTOCOMMIT = FALSE
-- MASQL/MARIADB : AUTOCOMMIT = TRUE

-- 접속한 유저의 테이블 목록보기 SQL명령어
SELECT * FROM USER_TABLES;

-- DROP TABLE : 테이블 삭제  
--DROP TABLE TB_DEPARTMENT;

-- 연습문제 1) EMPLOYEE 테이블의 구조만 복사하여 EMP_INSERT란 이름의 빈 테이블을 생성.
    CREATE TABLE EMP_INSERT AS SELECT * 
    FROM EMPLOYEE WHERE 1=2; -- 거짓 조건 (구조만 복사, 데이터X)
-- 2) 본인을 EMP_INSERT(임시 직원테이블) 테이블에 추가하되, 
--    SYSDATE를 이용해서 입사일을 오늘로 입력.
-- 테이블 구조보는법
DESC EMP_INSERT; 
-- 컬럼 목록보는 딕셔너리
SELECT * FROM USER_TAB_COLUMNS
ORDER BY TABLE_NAME;
-- 테이블에 데이터 넣기 ( 컬럼에 문자열 , 숫자 , NULL 값을 정확히 맞춰서 입력)
    INSERT INTO EMP_INSERT -- INSERT 부분에 (ENO, ENAME) 등 컬럼을 넣어서 입력가능
    VALUES(1,'JUNSEOP','STAFF',NULL,SYSDATE,2700,230,10);
    
    SELECT * FROM EMP_INSERT;
-- 3) EMP_INSERT(임시 직원테이블) 테이블에 옆 사람을 추가하되 TO_DATE 함수를
--    이용해서 입사일을 어제로 입력.
    INSERT INTO EMP_INSERT
    VALUES(2,'Kim','STUDENT',NULL,TO_DATE(SYSDATE-1,'YY/MM/DD'),1150,NULL,20);
-- 4) EMPLOYEE 테이블의 구조와 내용을 복사하여 EMP_COPY란 이름의 테이블 생성.
    CREATE TABLE EMP_COPY
    AS
    SELECT * FROM EMPLOYEE;

-- 10번문제 : DML(데이터 조작어) 실습
-- 5) 사원번호가 7788인 사원의 부서번호를 10번으로 수정하시오.
    UPDATE EMP_COPY
    SET DNO = 10
    WHERE ENO = 7788;
-- 6) 사원번호 7788의 담당업무(JOB) 및 급여(SALARY)를 사원번호 7499의
-- 담당업무 및 급여와 일치하도록 수정하시오.
    UPDATE EMP_COPY
    SET (JOB, SALARY) = (SELECT JOB, SALARY FROM EMP_COPY WHERE ENO = 7499)
    WHERE ENO = 7788;
    SELECT * FROM EMP_COPY;
-- 7) DEPARTMENT 테이블의 구조와 내용을 복사하여 DEPT_COPY란 이름의 테이블을
--    생성.
    CREATE TABLE DEPT_COPY AS SELECT * FROM DEPARTMENT;

-- 8) DEPT_COPY 테이블에서 부서명(DNAME)이 RESERCH인 부서를 제거.
    DELETE FROM DEPT_COPY
    WHERE DNAME = 'RESERCH';
-- 9) DEPT_COPY 테이블에서 부서 번호가 10이거나 40인 부서를 제거.
    DELETE FROM DEPT_COPY
    WHERE DNO IN(10, 40);
    
    COMMIT;
-- 도전과제 10) DEPT_COPY 테이블에서 부서명(DNAME)이 'SALES'이면
--         지역명(LOC)에 'SEOUL'이라고 수정하고, 아니면 'BUSAN' 수정.
    UPDATE DEPT_COPY
    SET LOC = DECODE (DNAME,'SALES','SEOUL'
                                    ,'BUSAN');

-- 2022-05-04 데이터 무결성(PK/EK)실습
-- 제약조건(Constraint)
-- 테이블의 컬럼에 유효하지 않은 값을 걸러내기 위해 걸어주는 것.
-- 무결성 제약조건 
-- 1) NOT NULL 조건
CREATE TABLE CUSTOMER(
    ID VARCHAR2(20) NOT NULL,
    PWD VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(20) NOT NULL,
    PHONE VARCHAR2(30),
    ADDRESS VARCHAR2(100)
);

-- NOT NULL : INSERT 테스트
INSERT INTO CUSTOMER
VALUES(NULL, NULL, NULL, '010-1111-1111','BUSAN'); -- 제약조건 때문에 에러남.

-- 2) UNIQUE : 테이블의 컬럼에 데이터가 무조건 유일한 값만 들어갈 수 있게 함. (중복 허용X)
CREATE TABLE CUSTOMER2(
    ID VARCHAR2(20) UNIQUE,
    PWD VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(20) NOT NULL,
    PHONE VARCHAR2(30),
    ADDRESS VARCHAR2(100)
);

-- NULL : UNIQUE 제약조건에 위반되지않음 (NULL은 중복가능)
INSERT INTO CUSTOMER2
VALUES('1', '1111', '홍길동', '010-1111-1111','BUSAN');
VALUES('1', '1111', '이순신', '010-1111-1111','BUSAN'); -- ID에 UNIQUE 중복된데이터 에러!!

SELECT * FROM CUSTOMER2;

-- 제약조건에 이름을 지정할 수 있음
CREATE TABLE CUSTOMER3(
    ID VARCHAR2(20) CONSTRAINT UK_ID UNIQUE,
    PWD VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(20) NOT NULL,
    PHONE VARCHAR2(30),
    ADDRESS VARCHAR2(100)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CUSTOMER3';

-- 3) PRIMARY KEY *****
-- UNIQUE + NOT NULL 효과 : 유일한 값 + NOT NULL조건 + INDEX생성됨(자동)

CREATE TABLE CUSTOMER4(
    ID VARCHAR2(20),
    PWD VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(20) NOT NULL,
    PHONE VARCHAR2(30),
    ADDRESS VARCHAR2(100),
    CONSTRAINT PK_ID PRIMARY KEY(ID)
);


INSERT INTO CUSTOMER4
VALUES(NULL, '1111', '홍길동', '010-1111-1111','BUSAN'); -- 제약조건 에러
INSERT INTO CUSTOMER4
VALUES(NULL, '1111', '이순신', '010-1111-1111','BUSAN'); -- 제약조건 에러

-- 4) FOREIGN KEY : 참조되는 테이블에 컬럼 값이 항상 존재햐아함
-- 부모테이블 (ID : 1,2,3) 자식테이블 (ID : 1,2,3, FDSA)
-- 예 ) 부모테이블 : 부서테이블(영업,기술,운영) , 자식테이블 (영업,기술,운영)
SELECT * FROM DEPARTMENT;
-- FK 테스트 테이블
CREATE TABLE EMP_SECOND (
    ENO NUMBER(4) CONSTRAINT PK_ENO PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DNO NUMBER(2) CONSTRAINT FK_DNO2 REFERENCES DEPARTMENT);
--        : 직원 => FK(참조 무결성)

INSERT INTO EMP_SECOND(ENO, ENAME, DNO)
VALUES(8000, '이순신',40);

-- DEFAULT 제약조건 :
-- 컬럼에 데이터가 아무런 값이 입력되지 않았을 때 디폴트로 지정된 값이 입력됨

CREATE TABLE EMP_THIRD (
    ENO NUMBER(4) CONSTRAINT PK_ENO2 PRIMARY KEY,
    ENAME VARCHAR2(10),
    SALARY NUMBER(7,2) DEFAULT 1000);
    -- DEFAULT 테스트
    INSERT INTO EMP_THIRD(ENO, ENAME)
    VALUES(8000,'홍길동');
    -- 데이터 확인
    SELECT * FROM EMP_THIRD;
    
-- 테이블 정리
SELECT TABLE_NAME FROM USER_TABLES;
DROP TABLE EMP_INSERT;

-- EMP_COPY 테이블:
CREATE TABLE EMP_COPY
AS
SELECT *
FROM EMPLOYEE;

-- DEPT_COPY 테이블:
CREATE TABLE DEPT_COPY
AS
SELECT *
FROM DEPARTMENT;

-- 테이블 만들고 난 후에 제약조건 걸기
ALTER TABLE EMP_COPY
ADD CONSTRAINT PK_EMP_COPY_ENO PRIMARY KEY(ENO);

ALTER TABLE DEPT_COPY
ADD CONSTRAINT PK_EMP_COPY_DNO PRIMARY KEY(DNO);

-- 제약조건 보는 딕셔너리 SQL문
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';

-- 제약조건에 따른 테이블, 컬럼을 보는 SQL문
SELECT B.TABLE_NAME, A.COLUMN_NAME, B.CONSTRAINT_TYPE
FROM    USER_CONS_COLUMNS A,
        USER_CONSTRAINTS B
WHERE A.CONSTRAINT_NAME = B.CONSTRAINT_NAME
AND B.TABLE_NAME NOT LIKE 'BIN%'
ORDER BY B.TABLE_NAME;
-- FOENIGN KEY 생성
ALTER TABLE EMP_COPY
ADD CONSTRAINT FK_EMP_COPY_DNO
FOREIGN KEY(DNO) REFERENCES DEPT_COPY(DNO);

-- 제약조건이 생성된 후 삭제.하기
-- 에러) 먼저 자식테이블의 FOREIGN KEY 를 제거.하고 ,
--      부모테이블의 PRIMARY KEY를 제거.해야함
ALTER TABLE DEPT_COPY
DROP PRIMARY KEY; -- 에러

-- 알아서 삭제.해 주세요
-- CASCADE : PRIMARY KEY와 동시에 동시에 
--           자식테이블의 FOREING KEY를 찾아서 알아서 삭제.함
ALTER TABLE DEPT_COPY
DROP PRIMARY KEY CASCADE;

-- 연습문제 1번 : 제약조건(Constraint) 실습
-- 1) EMPLOYEE 테이블의 구조를 복사하여 EMP_SAMPLE이란 이름의 테이블을 만드시오.
CREATE TABLE EMP_SAMPLE AS SELECT * FROM EMPLOYEE;
DROP TABLE EMP_SAMPLE;
CREATE TABLE EMP_SAMPLE AS SELECT * FROM EMPLOYEE WHERE 1=2;
-- 사원 테이블의 사원번호 컬럼(ENO)에 테이블 레벨로 PRIMARY KEY 제약조건을 지정하되,
DESC EMP_SAMPLE;
-- 제약 조건 이름은 PK_MY_EMP 로 하시오.
ALTER TABLE EMP_SAMPLE
ADD CONSTRAINT PK_MY_EMP PRIMARY KEY(ENO);

-- 2) DEPARTMENT 테이블의 구조를 복사하여 DEPT_SAMPLE란 이름의 테이블을 생성.
-- 부서번호 컬럼(DNO)에 PRIMARY KEY 제약조건을 지정하되,
-- 제약조건 이름은 PK_MY_DEPT 하시오.
CREATE TABLE DEPT_SAMPLE AS SELECT * FROM DEPARTMENT WHERE 1=2;
DROP TABLE DEPT_SAMPLE;

ALTER TABLE DEPT_SAMPLE
ADD CONSTRAINT PK_MY_DEPT PRIMARY KEY(DNO);

-- 3) 사원 테이블의 부서번호 컬럼에 존재하지 않는 부서의 사원이 배정되지 않도록
--    외래 키(FOREIGN KEY: FK) 제약조건을 지정하되, FK_MY_DEPT_EMP로 하시오.
ALTER TABLE EMP_SAMPLE
ADD CONSTRAINT FK_MY_DEPT_EMP
FOREIGN KEY(DNO) REFERENCES DEPARTMENT(DNO);


